.. _lectures-content-label:

Краткий конспект лекций
=======================

Лекция 1. Установочная встреча.
-------------------------------

Знакомство с преподавателем. Общая структура курса. Формирование
итоговой оценки. Основные идеи, закладываемые в курс. Место курса в
образовательной программе. Создатель языка Python. Историческая
перспектива на версии языка. Семантическое версионирование. Области
использования языка.

Лекция 2. Примитивные типы. Условия.
------------------------------------

Типы ``int`` и ``float``. Способы создания: литералы и вызов типа.
Переменная как ссылка в памяти. Объект в памяти: значение, тип,
количество ссылок. Неизменяемость. Операции над числами. Краткая запись.
Отличия различных способов деления. Операторы сравнения. Тип ``bool``.
Структура условия: ``if/elif/else``. Явное и неявное приведение.
Форматирование нескольких условий. Особенности выполнения цепочек
условий с ``and`` и ``or``. Тип ``str``. Особенности создания строк.
Экранирование. Управляющие последовательности (``escape sequences``).

Лекция 3. Строки: неизменяемые последовательности.
--------------------------------------------------

Последовательности в ``Python``: ``str``, ``list`` и ``tuple``. Ключевые
свойства последовательностей. Индексируемость. Срезы: особенности
использования, синтаксиса. Срезы как способ копирования
последовательностей. Итерируемость. Варианты обхода последовательности:
по элементам, по индексам (``range``), одновременно по индексам и
значениям (``enumerate``). Взятие длины последовательности. Проверка на
вхождение. Получение минимального и максимального элементов. Подсчет
количества вхождений элемента. Получение индекса первого вхождения
элемента по его значению. Строковые методы. Особенности использования
методов ``split``, ``join``. Форматирование строк с помощью
``f-string``.

Лекция 4. Списки и кортежи.
---------------------------

Способы создания списков. Изменяемость списков: добавление, удаление и
изменение существующих элементов. Срезы как способ поверхностного
копирования. Ловушка разделяемых ссылок. Глубокое копирование.
Преимущества и недостатки различных способов копирования. Способы
создания кортежей. Структурная неизменяемость кортежей. Основные
преимущества от использования кортежей.

Лекция 5. Словари.
------------------

Способы создания словарей. Разница в поведении оператора квадратные
скобки при извлечении значений в словаре и списке. Изменяемость
словарей. Добавление новых элементов в словарь. Удаление элементов из
словаря. Изменение существующих элементов. Уникальность ключей.
Требования к ключам словаря. Итерирование по ключам, значениям и парам,
хранящимся в словаре. Проверка на вхождение ключа с помощью оператора
``in``. Получение размера словаря с помощью ``len()``.

Лекция 6. Функции.
------------------

Объявление функции с помощью ``def``. Требования и рекомендации к
именованию функций. Аргументы функции: позиционные и именованные.
Опциональные подсказки типов в описании аргументов и возвращаемых
значений. Вызов функции и её объявление. Возврат результатов функции с
помощью ``return``. Возврат и обработка нескольких значений.
Сопоставление аргументов при вызове функции: позиционное и по имени.
Произвольное количество аргументов функции при помощи ``*args`` и
``**kwargs``.

Лекция 7. Введение в ООП. Класс как пользовательский тип.
---------------------------------------------------------

Парадигмы программирования как способ борьбы с возрастающей сложностью
программного обеспечения. Состояние и поведение как ключевые факторы
программ, требующие управления. Императивно-процедурное
программирование. Функциональное программирование.
Объектно-ориентированное программирование. Класс как пользовательский
тип. Класс как совокупность свойств и поведения. Синтаксис создания
классов. Объект ``self``. Создание атрибутов экземпляров. Роль метода
``__init__``. Доступ к атрибутам и методам экземпляра внутри контекста
класса и за его пределами.

Лекция 8. Разбор технического задания по лабораторной работе №3.
----------------------------------------------------------------

Основные строительные блоки для обработки текста. Понятие n-граммы. Генерация текста с помощью
n-грамм. Жадная стратегия генерации текста. Стратегия генерации ``Beam Search``. Стратегия
генерации ``Back-off``.

Лекция 9. Инкапсуляция.
-----------------------

Создание экземпляров классов: без поведения и без состояния, с поведением и без состояния, с
поведением и с состоянием. Изменяемость пользовательского типа. Интуитивное понятие интерфейса
в объектах окружающего мира. Интерфейс как способ управления сложностью. Интерфейс функции.
Интерфейс класса. Инкапсуляция как принцип объединения методов и свойств во внутреннем состоянии
объекта. Сокрытие данных как основное свойство инкапсуляции. Соотношение понятий инкапсуляции
и сокрытия данных. Механика реализации сокрытия данных в Python: ``protected`` и ``private``
поля и методы. Доступ к защищённым и приватным полям за пределами контекста класса.

Лекция 10. Наследование.
------------------------

Наследование как способ избежать дублирования кода на уровне классов.
Диаграмма классов UML для формального описания создаваемых абстракций.
Отличия в наследовании атрибутов и методов. Особенности наследования атрибутов в зависимости от
уровня доступа. ``super()`` для обращения к родительскому классу. Множественное наследование.
Проблема ромба. ``__mro__`` в Python для решения проблемы ромба.
Диаграмма классов UML для формального описания создаваемых абстракций.

Лекция 11. Полиморфизм.
-----------------------

Полиморфизм в окружающем мире и в программах на Python. Полиморфность объектов, находящихся в
отношении наследования. Перегрузка методов классов для реализации различного поведения.
Протоколы языка Python. Перегрузка приведения к строке через ``__str__``,
получения количества элементов ``__len__``, итерирования через ``__iter__`` и ``__next__``.

Лекция 12. Исключения.
-----------------------

Разбор сообщений об ошибках в терминале командой строки. Исключения как результат нестандартного
поведения. Часто возникающие исключения. Иерархия наследования исключений в Python. Разница
между ``BaseException`` и ``Exception``. Конструкция `try/except/else/finally`. Особенности
использования ``except`` для обработки исключений в случае отсутствия явного типа
исключения или использования в качестве ожидаемого класса-родителя группы исключений.
Получение доступа к экземпляру исключения. Гарантированность вызова блока ``finally`` и
мотивация для такого поведения. Стили работы с ошибками во время выполнения
программы: `LBYL (look before you leap)` и `EAFP (easier to ask for forgiveness than permission)`.
Сравнение подходов. Исключения как дополнительный канал обмена информацией. Поднятие и
перехват исключений. Выбор между ``return`` и поднятием исключения.

Лекция 13. Области видимости.
-----------------------------

Четыре области видимости в Python. Правило LEGB. Связь локальной области видимости и функций.
Необходимые предпосылки для возникновения объемлющей области видимости. Связь глобальной области
видимости и модулей. Опасности в переопределении объектов из встроенной области видимости и почему
переопределение работает. Изменение глобальных переменных из функций. Изменение объектов из
объемлющей области видимости. Замыкание. Мемоизация как способ кеширования результатов вычислений.
